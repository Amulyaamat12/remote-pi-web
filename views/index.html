<canvas></canvas>
<script src="./socket.io/socket.io.js"></script>
<script>
const REFRESH_INTERVAL_MS = 5 * 1000

function getAppPath() {
  const pathname = window.location.pathname
  const matchArr = pathname.match(/(^.*)(\/.*$)/)
  if (matchArr) {
    const [, path, suffix] = matchArr
    if (!suffix.includes('.')) return pathname
    return path
  }
  return pathname
}
const appPath = getAppPath()
const state = {
  canvas: document.querySelector('canvas'), // defaults to 300x150
  ratio: null,
}
state.ctx = state.canvas.getContext('2d')

state.draw = () => {
  // contain image within view
  const maxWidth = window.innerWidth
  const maxHeight = window.innerHeight
  const imageWidth = state.image.width
  const imageHeight = state.image.height
  state.canvas.width = imageWidth
  state.canvas.height = imageHeight
  state.ratio = null

  if (maxWidth < imageWidth) {
    if (imageWidth > maxWidth) {
      state.canvas.width = maxWidth
      state.ratio = imageWidth / maxWidth
      state.canvas.height = imageHeight / state.ratio
    }
  }
  if (!state.ratio && maxHeight < imageHeight) {
    if (imageHeight > maxHeight) {
      state.canvas.height = maxHeight
      state.ratio = imageHeight / maxHeight
      state.canvas.width = imageWidth / state.ratio
    }
  }
  state.ctx.drawImage(state.image, 0, 0, state.canvas.width, state.canvas.height)
  state.topOffset = state.canvas.getBoundingClientRect().top
  state.leftOffset = state.canvas.getBoundingClientRect().left
}

state.drawImageFromSocket = (data) => {
  state.image = new Image()
  const arrayBufferView = new Uint8Array(data)
  const blob = new Blob([ arrayBufferView ], { type: 'image/jpeg'})
  state.image.src = window.URL.createObjectURL(blob)
  state.image.onload = state.draw
}

const socket = io(appPath)

/*
 * USAGE:
 * document.querySelector('.thing').addEventListener('scroll', e => debounce(e, cb));
 */
let lastBounce = Date.now();
let queuedBounce = false;
function debounce(e, callback, delayMS = 100) {
  const epoch = Date.now();
  if (epoch - lastBounce > delayMS) {
    callback();
    lastBounce = Date.now();
  } else if (!queuedBounce) {
    queuedBounce = true; // lock
    setTimeout(() => { // queue a bounce
      callback();
      lastBounce = Date.now();
      queuedBounce = false;
    }, delayMS);
  }
}
function controlObj(ev, useMouse = false) {
  state.lastClickX = ev.x - state.leftOffset
  state.lastClickY = ev.y - state.topOffset
  const controlObj = {
    x: parseInt(state.lastClickX * state.ratio),
    y: parseInt(state.lastClickY * state.ratio),
  }
  if (useMouse) controlObj.click =  mapButton(ev.button)
  return controlObj
}
state.canvas.addEventListener('mousemove', (ev) => debounce(ev, () => {
  socket.emit('control', controlObj(ev))
}, 500))
state.canvas.addEventListener('mousedown', (ev) => {
  socket.emit('control', controlObj(ev, true))
})
// prevent right-click menu
document.addEventListener('contextmenu', (ev) => ev.preventDefault())
function mapButton(eventButton) { return [1, 2, 3][eventButton] }

const refreshHandle = setInterval(() => {
  if (!document.hidden) { // active tab
    socket.emit('screen')
  }
}, REFRESH_INTERVAL_MS)

socket.on('connect', function(){
  socket.emit('screen')
  window.onresize = () => state.draw()
})

socket.on('render', state.drawImageFromSocket)

socket.on('disconnect', function(){
  console.warn('disconnected from socket')
})
</script>